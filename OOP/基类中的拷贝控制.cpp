/*
 * 拷贝控制操作有：
 * 1. 拷贝构造函数
 * 2. 拷贝赋值运算符
 * 3. 移动构造函数
 * 4. 移动赋值运算符
 * 5. 析构函数
 * 如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作
 * 浅拷贝会对自动合成的造成灾难
 * 
 * 有析构函数必然有拷贝构造函数和拷贝赋值运算符（有外部资源需要被释放，则需要深拷贝）
 * 有拷贝构造函数和拷贝赋值运算符不一定有析构函数（生成一个独一无二的值）
 */

/*
 * 移动而非拷贝对象会大幅提升性能
 *
 * 虽然不能直接将一个右值引用直接绑定到一个左值上，但使用 std::move() 可以显式的将一个左值转换为对应的右值引用类型
 * int &&rr = std::move(rr1) // 调用std::move() 就意味着除了销毁或赋值它，不再使用它
 * 由于移动操作窃取资源，通常不分配任何资源，它不应抛出异常 noexcept
 *
 * 合成的移动操作
 * 如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符、析构函数 编译器不会为它合成移动构造函数和移动赋值运算符 （Base::~Base() = delete 也被认为已定义）
 * 如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作（用拷贝操作代替移动操作几乎总是安全地）
 * （当一个类没有定义任何版本的拷贝控制成员时，且所有资源可被移动构造或移动赋值时，编译器才会为其合成移动构造函数或移动赋值运算符）
 *
 * 派生类中的移动操作
 * 
 */

#include <iostream>

using namespace std;

class Base {
public:

};

int main() {

}